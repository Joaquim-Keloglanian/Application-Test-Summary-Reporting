1. Objective of the Test
The objective of this engagement was to assess the security posture of the login module by means of a static review of the server-side Java codebase and associated web resources. The review focused on authentication logic, input handling, database access patterns, cryptographic controls, error handling, and configuration. The intended outcome was to identify vulnerabilities and weaknesses and to provide clear, actionable remediation guidance.

2. Testing Approach
The assessment was conducted as a manual secure code review (SAST) of the specified source tree, tracing data flows from HTTP request parameters to security-sensitive sinks such as database queries, cryptographic operations, session handling, and response generation. The review drew on OWASP ASVS v4.0.3 (authentication, session management, data protection), the OWASP Top 10 (2021), and relevant OWASP Cheat Sheets (e.g., Password Storage, SQL Injection). No compilation or execution of the application was performed. No database or application server configuration was inspected. Software composition analysis (SCA) and dynamic scanning were not included.

3. Areas Tested
Backend (Java)
  • ishop/service/Logins.java: Login servlet responsible for processing POST/GET requests, constructing queries, validating passwords, and issuing session tokens.
  • ishop/service/DataServices.java: Database connectivity and generic query execution.
  • ishop/service/SecurePassword.java: Password hashing and verification utilities.
Frontend / Web Resources
  • webapp/login.html: Login form and related modals.
  • webapp/WEB-INF/web.xml: Servlet mappings, welcome page, and context parameters.

4. Areas Not Tested
The following items were not examined within the scope of this static review:
  • Business logic and servlets referenced but not present in the reviewed source snapshot (e.g., AddUser, ForgottenPassword).
  • Third-party libraries under WEB-INF/lib.
  • Application server/container configuration (e.g., HTTPS enforcement, session cookie flags) and any reverse proxy or CDN settings.
  • Database schema, roles and permissions, and production credentials.
  • Functionality outside the login and authentication flow.

5. Platform Details
  • Language/stack: Jakarta Servlet API (jakarta.servlet.*), Java, JSON-simple.
  • Database: PostgreSQL (org.postgresql.Driver).
  • Environment: Review conducted on Windows. A hard-coded JDBC URL referencing localhost:5432 was observed.

6. Defect Report (Static Findings)
Severity scale: Critical, High, Medium, Low

CRITICAL-1: Broken password validation (salt/hash order; reduced derived key length)
  • Location: SecurePassword.java (validatePassword)
  • Description: Passwords are stored as "salt:hash" by generateStrongPasswordHash. In validatePassword, the components are parsed in reverse (part[1] used as salt and part[0] used as hash). The derived key length for PBKDF2 is then based on the (misinterpreted) hash byte array which actually corresponds to the salt length (typically 16 bytes → 128 bits), rather than the original 512-bit PBKDF2 output. This results in incorrect verification and materially weakens the protection against offline attacks.
  • Impact: Valid users may be denied access. If storage is adapted to match the bug, the effective hash length is significantly reduced, increasing susceptibility to brute-force attacks.
  • Recommendation: Parse as salt = part[0], hash = part[1]. Derive the PBKDF2 output with the same bit length used at generation. Compare using a constant-time method. Introduce unit tests for both generation and validation paths.

HIGH-1: SQL constructed via string concatenation (SQL Injection risk)
  • Location: Logins.java (concatenated WHERE clause using username); DataServices.java (Statement.executeQuery(sql)).
  • Description: User-controlled input (username) is concatenated into SQL statements. Although a restrictive email regex is applied, input validation is not a substitute for parameterized queries.
  • Impact: Risk of SQL Injection if validation is bypassed, altered, or reused incorrectly. The generic DataServices pattern encourages additional unsafe queries.
  • Recommendation: Replace with PreparedStatement and bind parameters. Provide safe query helpers and return domain objects rather than string matrices.

HIGH-2: Hard-coded database credentials
  • Location: DataServices.java (databaseConnection)
  • Description: The JDBC URL embeds user=postgres and password=postgres in source control.
  • Impact: Credential leakage, operational inflexibility, and risk of reuse across environments.
  • Recommendation: Externalize secrets via JNDI DataSource, environment variables, or a secrets manager. Remove credentials from the codebase.

HIGH-3: Outdated and under-strength password hashing parameters
  • Location: SecurePassword.java (ITERATIONS=1024; PBKDF2WithHmacSHA1)
  • Description: The iteration count is below current recommendations, and HMAC-SHA1 is legacy.
  • Impact: Increased feasibility of offline cracking of stolen password hashes.
  • Recommendation: Adopt PBKDF2WithHmacSHA256 with a calibrated iteration count (e.g., ≥210,000; target ~100ms on production hardware), or use Argon2id with memory-hard parameters. Store as algorithm:iterations:salt:hash.

MEDIUM-1: Missing handling for “user not found”
  • Location: Logins.java
  • Description: The code accesses ans.get(1) without confirming that a row exists (ans.size() > 1). If the user is not found, an IndexOutOfBoundsException may occur.
  • Impact: Potential HTTP 500 responses and information leakage if stack traces are exposed.
  • Recommendation: Check for an empty result set and return HTTP 401 for invalid credentials without throwing exceptions.

MEDIUM-2: Excessive logging and stack traces
  • Location: DataServices.java and Logins.java
  • Description: Raw SQL statements and stack traces are printed to standard output.
  • Impact: Potential disclosure of sensitive information through log mining.
  • Recommendation: Use a structured logging framework. Avoid logging sensitive values. Log minimal context at appropriate levels and suppress stack traces from end users.

MEDIUM-3: Incorrect response Content-Type for JSON
  • Location: Logins.java
  • Description: The response Content-Type is set to text/html while a JSON document is returned.
  • Impact: Content sniffing issues, tooling incompatibilities, and potential security side effects.
  • Recommendation: Set Content-Type to application/json and add X-Content-Type-Options: nosniff. Consider appropriate cache-control headers for authentication responses.

MEDIUM-4: Lack of CSRF protections
  • Location: login.html; Logins.java
  • Description: No anti-CSRF token is implemented, and there is no explicit SameSite strategy.
  • Impact: Risk of login CSRF and contribution to clickjacking or session fixation patterns.
  • Recommendation: Rely on SameSite=Lax/Strict cookies for authentication and require CSRF tokens for state-changing actions. Apply protections consistently across the application.

MEDIUM-5: Session identifier exposed in response body
  • Location: Logins.java
  • Description: The servlet returns the session ID in the JSON body.
  • Impact: If transport or cookie flags are misconfigured, the session may be more easily intercepted or abused.
  • Recommendation: Rely on container-managed session cookies (HttpOnly, Secure, SameSite) and avoid echoing session IDs in JSON. If an API token is required, issue a dedicated opaque token or a well-configured JWT with rotation.

MEDIUM-6: External script without Subresource Integrity (SRI)
  • Location: login.html (jQuery from ajax.googleapis.com)
  • Description: The external resource is included without integrity and crossorigin attributes.
  • Impact: Supply-chain risk if the CDN is compromised.
  • Recommendation: Add SRI attributes or self-host the dependency. Consider a baseline Content Security Policy (CSP).

LOW-1: Resource management patterns
  • Location: DataServices.java
  • Description: JDBC resources are not managed with try-with-resources, risking leaks on exceptions.
  • Impact: Potential resource leaks and instability under error conditions.
  • Recommendation: Adopt try-with-resources for Connection, Statement, and ResultSet.

LOW-2: Overlapping servlet mappings
  • Location: Logins.java (@WebServlet("/Logins")); web.xml ("/ishop/service/Logins")
  • Description: Both annotation-based and deployment-descriptor mappings are defined.
  • Impact: Increased maintenance complexity and a larger externally reachable surface area.
  • Recommendation: Standardize on either annotations or web.xml for mapping. Remove redundant routes.

LOW-3: Absence of transport security policy in web.xml
  • Location: web.xml
  • Description: No security-constraint is defined to enforce CONFIDENTIAL (HTTPS) for authentication endpoints.
  • Impact: Risk of clear-text transmission if deployed without external TLS enforcement.
  • Recommendation: Enforce HTTPS via security-constraints and/or infrastructure (TLS termination with HSTS).

LOW-4: Legacy PRNG selection
  • Location: SecurePassword.java
  • Description: SecureRandom.getInstance("SHA1PRNG") is used.
  • Impact: Reliance on a legacy algorithm without material benefit.
  • Recommendation: Use new SecureRandom() or getInstanceStrong() (with consideration for blocking behavior). Document salt size explicitly.

7. Testing Metrics (Static)
  • Files reviewed: 5
    – Java: 3 (Logins.java, DataServices.java, SecurePassword.java)
    – Web: 2 (login.html, WEB-INF/web.xml)
  • Findings: 1 Critical, 3 High, 6 Medium, 4 Low (14 total)
  • Coverage: 100% of files in scope for the login module under the specified path.

8. Overall Summary
The login module exhibits several material security issues. The most urgent remediations are: (1) correcting the password verification logic to align with the storage format and intended derived key length; (2) eliminating dynamic SQL in favor of parameterized queries; (3) removing hard-coded database credentials; and (4) modernizing password hashing parameters and algorithms. Medium-priority improvements include robust handling of nonexistent users, safe logging practices, use of the correct JSON Content-Type with defensive headers, CSRF/session hardening, and the addition of SRI for external scripts. Low-priority but valuable hardening includes consolidating servlet mappings, enforcing HTTPS at the descriptor or infrastructure level, adopting try-with-resources for JDBC, and using a modern PRNG.

9. Recommended Next Steps (Priority Order)
  1) Correct SecurePassword.validatePassword() to parse salt and hash in the stored order and to derive the intended key length/algorithm. Add unit tests.
  2) Replace dynamic SQL with PreparedStatement-based queries; retain email validation but do not rely on it for injection defense.
  3) Externalize database credentials (JNDI, environment variables, or secrets management) and remove hard-coded secrets from source.
  4) Upgrade the KDF to PBKDF2-HMAC-SHA256 with a calibrated iteration count (or Argon2id) and plan a migration of existing hashes.
  5) Handle “user not found” conditions without exceptions and consistently return HTTP 401 for invalid credentials.
  6) Set Content-Type: application/json and add X-Content-Type-Options: nosniff; apply suitable cache controls.
  7) Avoid returning session identifiers in response bodies; rely on secure, HttpOnly cookies or issue purpose-built tokens.
  8) Add SRI to external scripts (or self-host) and consider deploying a baseline CSP.
  9) Consolidate servlet mappings and enforce HTTPS via security-constraints and infrastructure (TLS/HSTS).
  10) Adopt try-with-resources for JDBC and implement centralized, redacted logging.

Appendix A. Suggested Screenshots (concise)
To support the static findings with minimal but sufficient visual evidence, capture the following code excerpts. Keep each screenshot tightly cropped to the specified lines.

1) CRITICAL-1 (Broken password validation)
  • File: src/main/java/ishop/service/SecurePassword.java, lines 45–53
  • Rationale: Shows reversed parsing of salt/hash and the derived key length based on the wrong component.

2) HIGH-1 (SQL concatenation)
  • File: src/main/java/ishop/service/Logins.java, lines 63–68
  • Rationale: Shows construction of a query via string concatenation and execution via DataServices.doQuery.

3) HIGH-2 (Hard-coded DB credentials)
  • File: src/main/java/ishop/service/DataServices.java, lines 24–28
  • Rationale: Shows the JDBC URL embedding user and password.

4) HIGH-3 (Weak KDF parameters and legacy algorithm)
  • File: src/main/java/ishop/service/SecurePassword.java, lines 14–27
  • Rationale: Shows ITERATIONS=1024 and PBKDF2WithHmacSHA1/512-bit output length used at generation.

5) MEDIUM findings combined (content type, unsafe indexing, session token in body)
  • File: src/main/java/ishop/service/Logins.java, lines 74–86
  • Rationale: A single capture evidences (a) text/html Content-Type while returning JSON, (b) direct access to ans.get(1).get(3), and (c) returning the session ID in the JSON response.

6) MEDIUM-6 (External script without SRI)
  • File: src/main/webapp/login.html, lines 232–236 (focus on line ~234)
  • Rationale: Shows the jQuery CDN include without integrity and crossorigin attributes.
