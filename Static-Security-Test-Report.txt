Static Security Test Summary Report – Login Module (SecTestSoft2025)

Date: 2025-11-05
Scope: Static (source) review only. No dynamic testing performed.
Repository path under review: Lab-4-Application-Security-Testing-2025\SecTestSoft2025\SecTestSoft2025\src\main

Objective of the test
- Assess the security posture of the login module by statically reviewing server-side Java and web resources.
- Identify vulnerabilities and weaknesses related to authentication, input handling, database access, cryptography, error handling, and configuration.
- Provide actionable remediation guidance and an executive-ready summary.

Testing approach
- Method: Manual secure code review (SAST) of the specified source tree focusing on data flows from HTTP request parameters to security-sensitive sinks (DB queries, crypto, session handling, output).
- Heuristics & references: OWASP ASVS v4.0.3 (authentication, session mgmt, data protection), OWASP Top 10 2021 (A01–A10), OWASP Password Storage and SQL Injection Cheat Sheets.
- What was NOT done: No compilation, no execution, no database/Tomcat configuration inspection, no dependency SCA, and no dynamic scanning.

Areas tested
- Backend (Java)
  1) ishop/service/Logins.java – Login servlet handling POST/GET, building SQL, validating password, issuing token.
  2) ishop/service/DataServices.java – Database connection and generic query execution.
  3) ishop/service/SecurePassword.java – Password hashing and verification utilities (PBKDF2).
- Frontend/Web resources
  4) webapp/login.html – Login form and related modals (sign up / forgotten password links).
  5) webapp/WEB-INF/web.xml – Servlet mappings, welcome page, and context params.

Areas not tested
- Business logic and servlets referenced but not present in this source sample (e.g., AddUser, ForgottenPassword) beyond their mention in HTML.
- Third-party libraries under WEB-INF/lib (not inspected).
- Server/container configuration (e.g., Tomcat HTTPS, session cookie flags) and reverse proxy/CDN setups.
- Database schema, roles/permissions, and production credentials.
- Any functionality outside the login/authentication flow.

Platform details
- Language/stack: Jakarta Servlet API (jakarta.servlet.*), Java, JSON-simple.
- Database: PostgreSQL (via org.postgresql.Driver).
- Environment: Static review on Windows; no runtime assumptions made. Observed hard-coded JDBC URL to localhost:5432.

Defect report (static findings)
Severity scale: Critical, High, Medium, Low

[CRITICAL-1] Broken password validation (salt/hash reversed; shortened key length)
- Location: SecurePassword.java::validatePassword
- Issue: storedPassword format is "salt:hash" (per generateStrongPasswordHash), but validatePassword splits and treats part[1] as salt and part[0] as hash. It then derives a key length based on the salt length (typically 16 bytes → 128 bits), not the original 512-bit length, and compares against the wrong array. This likely causes systematic auth failures and/or inconsistent behavior.
- Risk: Authentication may fail for valid users; if operators compensate in storage format, this still reduces derived key length, weakening resistance to offline cracking.
- Recommendation: Correct parsing to salt = part[0], hash = part[1]; derive with the same key length used at generation; add constant-time comparison. Add unit tests for both generation/validation.

[HIGH-1] SQL query built via string concatenation (SQL Injection risk)
- Location: Logins.java (builds "SELECT ... WHERE EMAIL='" + username + "'"), DataServices.java (Statement.executeQuery(sql)).
- Issue: User-supplied input (username) is concatenated into SQL. Although a restrictive email regex is applied, this is brittle and not a substitute for parameterized queries.
- Risk: SQL Injection if validation weakens/changes elsewhere; unsafe pattern encourages future mistakes; generic DataServices encourages arbitrary unsanitized queries.
- Recommendation: Use PreparedStatement with bind parameters; centralize safe query helpers; minimize dynamic SQL; return domain objects instead of raw String matrices.

[HIGH-2] Hard-coded database credentials
- Location: DataServices.java::databaseConnection
- Issue: JDBC URL contains user=postgres&password=postgres in source.
- Risk: Credential leakage, inability to rotate, accidental reuse across environments.
- Recommendation: Externalize secrets (JNDI DataSource, environment variables, or a secrets manager). Remove credentials from source control.

[HIGH-3] Weak KDF parameters and algorithm choice
- Location: SecurePassword.java (ITERATIONS=1024, PBKDF2WithHmacSHA1 512-bit)
- Issue: Iteration count is far below current guidance; HMAC-SHA1 is legacy.
- Risk: Faster brute-force/offline cracking of stolen hashes.
- Recommendation: Adopt PBKDF2WithHmacSHA256 with ≥210,000 iterations (OWASP 2023 guidance; calibrate to ~100ms on server hardware) or Argon2id with memory-hard params. Store as algorithm:iterations:salt:hash.

[MEDIUM-1] Missing safe handling when user not found
- Location: Logins.java
- Issue: Accesses ans.get(1) without verifying result contains a row (ans.size()>1). If user doesn’t exist, this can throw IndexOutOfBoundsException → potential 500 errors.
- Risk: Error handling bypasses intended 401 and may leak details if stack traces are exposed.
- Recommendation: Explicitly handle no-row case and return 401 consistently without exception.

[MEDIUM-2] Sensitive information in logs
- Location: DataServices.java logs raw SQL; stack traces printed in both DataServices and Logins.
- Risk: Log mining disclosure of queries and internals.
- Recommendation: Use a logging framework, avoid logging sensitive values; log minimal context at INFO/ERROR without PII/secrets; disable stack traces to end users.

[MEDIUM-3] Incorrect response Content-Type for JSON
- Location: Logins.java
- Issue: Sets text/html but returns JSON.
- Risk: Content sniffing, tooling interop issues, and potential XSS vectors in some contexts.
- Recommendation: Set application/json; include X-Content-Type-Options: nosniff. Consider cache controls for auth responses.

[MEDIUM-4] No CSRF protection on state-changing endpoints
- Location: login.html (form), Logins.java
- Issue: No anti-CSRF token or SameSite policy consideration.
- Risk: While login CSRF is less impactful than sensitive state changes, it can still cause unwanted sessions (“login CSRF”) or contribute to clickjacking flows.
- Recommendation: Rely on SameSite=Lax/Strict cookies and for privileged actions require CSRF tokens. Consider CSRF defenses framework-wide.

[MEDIUM-5] Session token exposure pattern
- Location: Logins.java
- Issue: Returns session ID in JSON. If not strictly over HTTPS and with proper cookie flags, interception risk increases.
- Recommendation: Use container-managed session cookie (HttpOnly, Secure, SameSite) and avoid echoing session IDs in bodies. If an API token is required, issue a dedicated opaque token or JWT with proper scopes and rotation.

[MEDIUM-6] External script without Subresource Integrity (SRI)
- Location: login.html (jQuery from ajax.googleapis.com)
- Risk: Supply-chain risk if CDN is compromised.
- Recommendation: Add integrity + crossorigin attributes or self-host.

[LOW-1] Resource handling and cleanup patterns
- Location: DataServices.java
- Issue: No try-with-resources; potential leaks on exceptions.
- Recommendation: Adopt try-with-resources for Connection/Statement/ResultSet.

[LOW-2] Dual servlet mappings (annotation + web.xml)
- Location: Logins.java (@WebServlet("/Logins")), web.xml ("/ishop/service/Logins").
- Issue: Redundant/overlapping routes increase attack surface and maintenance complexity.
- Recommendation: Choose a single mapping strategy (prefer annotations) and remove the other, or ensure both are required and consistently protected.

[LOW-3] No transport security policy in deployment descriptor
- Location: web.xml
- Issue: No <security-constraint> enforcing CONFIDENTIAL for auth endpoints.
- Recommendation: Enforce HTTPS transport; configure HSTS at edge.

[LOW-4] PRNG algorithm selection
- Location: SecurePassword.java
- Issue: SecureRandom.getInstance("SHA1PRNG") is legacy.
- Recommendation: Use new SecureRandom() or getInstanceStrong() (with care for blocking behavior), and explicitly document salt length.

Testing metrics (static)
- Files reviewed: 5
  - Java: 3 (Logins.java, DataServices.java, SecurePassword.java)
  - Web: 2 (login.html, WEB-INF/web.xml)
- Findings: 1 Critical, 3 High, 6 Medium, 4 Low (14 total)
- Coverage: 100% of files in scope for the login module under the specified path.

Overall summary
The login module presents several significant issues. The most urgent are: (1) fixing the broken password verification (salt/hash order and key length), (2) eliminating dynamic SQL in favor of PreparedStatement, (3) removing hard-coded DB credentials, and (4) modernizing password hashing parameters. Medium-priority improvements include robust error handling for not-found users, safer logging, correct JSON Content-Type with security headers, CSRF/session hardening, and SRI for third-party scripts. Low-priority but worthwhile hardening items include consolidating servlet mappings, enforcing HTTPS at the descriptor or infrastructure level, adopting try-with-resources, and using modern PRNG.

Recommended next steps (priority order)
1) Correct SecurePassword.validatePassword() to parse salt/hash in the same order they are stored and align key length/algorithm with generation.
2) Replace string SQL building with PreparedStatement and minimal-result queries; validate email server-side but do not rely on regex for injection defense.
3) Externalize DB credentials via JNDI or environment/secret management; remove hard-coded secrets from source.
4) Upgrade KDF to PBKDF2-HMAC-SHA256 with ≥210k iterations (or Argon2id) and migrate stored hashes.
5) Handle no-user-found path without exceptions; always return 401 for invalid credentials.
6) Set Content-Type: application/json and security headers (X-Content-Type-Options: nosniff; reasonable cache policy).
7) Avoid returning session IDs in bodies; rely on secure, HttpOnly cookies or issue purpose-built tokens.
8) Add SRI to external scripts or self-host; consider CSP in the application.
9) Consolidate servlet mappings; enforce HTTPS with security-constraints and infra (TLS/HSTS).
10) Adopt try-with-resources for JDBC; add centralized logging with redaction.
